import { Directive, ElementRef, Renderer2, Input, Output, EventEmitter, NgZone, Inject, PLATFORM_ID } from '@angular/core';
import { ResizeObserver as ResizeObserverPonyfill } from '@juggle/resize-observer';
import { take } from 'rxjs/operators';
import { Subject } from 'rxjs';
import { isPlatformBrowser } from '@angular/common';
let ResizeObserver = ResizeObserverPonyfill;
/**
 * Directive to truncate the contained text, if it exceeds the element's boundaries
 * and append characters (configurable, default '...') if so.
 */
export class EllipsisDirective {
    /**
     * The directive's constructor
     */
    constructor(elementRef, renderer, ngZone, platformId) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.platformId = platformId;
        /**
         * Subject triggered when resize listeners should be removed
         */
        this.removeResizeListeners$ = new Subject();
        /**
         * The ellipsis-content html attribute
         * If passed this is used as content, else contents
         * are fetched from textContent
         */
        this.ellipsisContent = null;
        /**
         * The ellipsis-click-more html attribute
         * If anything is passed, the ellipsisCharacters will be
         * wrapped in <a></a> tags and an event handler for the
         * passed function will be added to the link
         */
        this.moreClickEmitter = new EventEmitter();
        /**
         * The ellipsis-change html attribute
         * This emits after which index the text has been truncated.
         * If it hasn't been truncated, null is emitted.
         */
        this.changeEmitter = new EventEmitter();
    }
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param  max      Highest possible number
     * @param  callback Should return true as long as the passed number is valid
     * @return          Largest possible number
     */
    static numericBinarySearch(max, callback) {
        let low = 0;
        let high = max;
        let best = -1;
        let mid;
        while (low <= high) {
            // tslint:disable-next-line:no-bitwise
            mid = ~~((low + high) / 2);
            const result = callback(mid);
            if (!result) {
                high = mid - 1;
            }
            else {
                best = mid;
                low = mid + 1;
            }
        }
        return best;
    }
    /**
     * Convert ellipsis input to string
     * @param input string or number to be displayed as an ellipsis
     * @return      input converted to string
     */
    static convertEllipsisInputToString(input) {
        if (typeof input === 'undefined' || input === null) {
            return '';
        }
        return String(input);
    }
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     */
    ngAfterViewInit() {
        if (!isPlatformBrowser(this.platformId)) {
            // in angular universal we don't have access to the ugly
            // DOM manipulation properties we sadly need to access here,
            // so wait until we're in the browser:
            return;
        }
        // Prefer native ResizeObserver over ponyfill, if available:
        if (window.ResizeObserver != null) {
            ResizeObserver = window.ResizeObserver;
        }
        // let the ellipsis characters default to '...':
        if (this.ellipsisCharacters === '') {
            this.ellipsisCharacters = '...';
        }
        // create more anchor element:
        this.moreAnchor = this.renderer.createElement('a');
        this.moreAnchor.className = 'ngx-ellipsis-more';
        this.moreAnchor.href = '#';
        this.moreAnchor.textContent = this.ellipsisCharacters;
        // perform regex replace on word boundaries:
        if (!this.ellipsisWordBoundaries) {
            this.ellipsisWordBoundaries = '';
        }
        this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
        if (!this.ellipsisSubstrFn) {
            this.ellipsisSubstrFn = (str, from, length) => {
                return str.substr(from, length);
            };
        }
        // store the original contents of the element:
        this.elem = this.elementRef.nativeElement;
        if (typeof this.ellipsisContent !== 'undefined' && this.ellipsisContent !== null) {
            this.originalText = EllipsisDirective.convertEllipsisInputToString(this.ellipsisContent);
        }
        else if (!this.originalText) {
            this.originalText = this.elem.textContent.trim();
        }
        // add a wrapper div (required for resize events to work properly):
        this.renderer.setProperty(this.elem, 'innerHTML', '');
        this.innerElem = this.renderer.createElement('div');
        this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
        const text = this.renderer.createText(this.originalText);
        this.renderer.appendChild(this.innerElem, text);
        this.renderer.appendChild(this.elem, this.innerElem);
        this.previousDimensions = {
            width: this.elem.clientWidth,
            height: this.elem.clientHeight
        };
        // start listening for resize events:
        this.addResizeListener(true);
    }
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     */
    ngOnChanges(changes) {
        const moreAnchorRequiresChange = this.moreAnchor && changes['ellipsisCharacters'];
        if (moreAnchorRequiresChange) {
            this.moreAnchor.textContent = this.ellipsisCharacters;
        }
        if (this.elem
            && typeof this.ellipsisContent !== 'undefined'
            && (this.originalText !== EllipsisDirective.convertEllipsisInputToString(this.ellipsisContent)
                || moreAnchorRequiresChange)) {
            this.originalText = EllipsisDirective.convertEllipsisInputToString(this.ellipsisContent);
            this.applyEllipsis();
        }
    }
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     */
    ngOnDestroy() {
        // In angular universal we don't have any listeners hooked up (all requiring ugly DOM manipulation methods),
        // so we only need to remove them, if we're inside the browser:
        if (isPlatformBrowser(this.platformId)) {
            this.removeAllListeners();
        }
    }
    /**
     * remove all resize listeners
     */
    removeAllListeners() {
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        this.removeResizeListeners$.next();
        this.removeResizeListeners$.complete();
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param triggerNow=false if true, the ellipsis is applied immediately
     */
    addResizeListener(triggerNow = false) {
        if (typeof (this.resizeDetectionStrategy) === 'undefined') {
            this.resizeDetectionStrategy = '';
        }
        switch (this.resizeDetectionStrategy) {
            case 'manual':
                // Users will trigger applyEllipsis via the public API
                break;
            case 'window':
                this.addWindowResizeListener();
                break;
            default:
                if (typeof (console) !== 'undefined') {
                    console.warn(`No such ellipsis-resize-detection strategy: '${this.resizeDetectionStrategy}'. Using 'resize-observer' instead`);
                }
            // eslint-disable-next-line no-fallthrough
            case 'resize-observer':
            case '':
                this.addElementResizeListener();
                break;
        }
        if (triggerNow && this.resizeDetectionStrategy !== 'manual') {
            this.applyEllipsis();
        }
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever the window gets resized.
     */
    addWindowResizeListener() {
        const removeWindowResizeListener = this.renderer.listen('window', 'resize', () => {
            this.ngZone.run(() => {
                this.applyEllipsis();
            });
        });
        this.removeResizeListeners$.pipe(take(1)).subscribe(() => removeWindowResizeListener());
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     */
    addElementResizeListener() {
        const resizeObserver = new ResizeObserver(() => {
            window.requestAnimationFrame(() => {
                if (this.previousDimensions.width !== this.elem.clientWidth || this.previousDimensions.height !== this.elem.clientHeight) {
                    this.ngZone.run(() => {
                        this.applyEllipsis();
                    });
                    this.previousDimensions.width = this.elem.clientWidth;
                    this.previousDimensions.height = this.elem.clientHeight;
                }
            });
        });
        resizeObserver.observe(this.elem);
        this.removeResizeListeners$.pipe(take(1)).subscribe(() => resizeObserver.disconnect());
    }
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param max the maximum length the text may have
     * @return string       the truncated string
     */
    getTruncatedText(max) {
        if (!this.originalText || this.originalText.length <= max) {
            return this.originalText;
        }
        const truncatedText = this.ellipsisSubstrFn(this.originalText, 0, max);
        if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
            return truncatedText;
        }
        let i = max - 1;
        while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
            i--;
        }
        return this.ellipsisSubstrFn(truncatedText, 0, i);
    }
    /**
     * Set the truncated text to be displayed in the inner div
     * @param max the maximum length the text may have
     * @param addMoreListener=false listen for click on the ellipsisCharacters anchor tag if the text has been truncated
     * @returns length of remaining text (excluding the ellipsisCharacters, if they were added)
     */
    truncateText(max, addMoreListener = false) {
        let text = this.getTruncatedText(max);
        const truncatedLength = text.length;
        const textTruncated = (truncatedLength !== this.originalText.length);
        if (textTruncated && !this.showMoreLink) {
            text += this.ellipsisCharacters;
        }
        this.renderer.setProperty(this.innerElem, 'textContent', text);
        if (textTruncated && this.showMoreLink) {
            this.renderer.appendChild(this.innerElem, this.moreAnchor);
        }
        // Remove any existing more click listener:
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
            this.destroyMoreClickListener = null;
        }
        // If the text has been truncated, add a more click listener:
        if (addMoreListener && textTruncated) {
            this.destroyMoreClickListener = this.renderer.listen(this.moreAnchor, 'click', (e) => {
                if (!e.target || !e.target.classList.contains('ngx-ellipsis-more')) {
                    return;
                }
                e.preventDefault();
                this.moreClickEmitter.emit(e);
            });
        }
        return truncatedLength;
    }
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     */
    applyEllipsis() {
        // Remove the resize listener as changing the contained text would trigger events:
        this.removeResizeListeners$.next();
        // Find the best length by trial and error:
        const maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, curLength => {
            this.truncateText(curLength);
            return !this.isOverflowing;
        });
        // Apply the best length:
        const finalLength = this.truncateText(maxLength, this.showMoreLink);
        // Re-attach the resize listener:
        this.addResizeListener();
        // Emit change event:
        if (this.changeEmitter.observers.length > 0) {
            this.changeEmitter.emit((this.originalText.length === finalLength) ? null : finalLength);
        }
    }
    /**
     * Whether the text is exceeding the element's boundaries or not
     */
    get isOverflowing() {
        // Enforce hidden overflow (required to compare client width/height with scroll width/height)
        const currentOverflow = this.elem.style.overflow;
        if (!currentOverflow || currentOverflow === 'visible') {
            this.elem.style.overflow = 'hidden';
        }
        const isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
        // Reset overflow to the original configuration:
        this.elem.style.overflow = currentOverflow;
        return isOverflowing;
    }
    /**
     * Whether the `ellipsisCharacters` are to be wrapped inside an anchor tag (if they are shown at all)
     */
    get showMoreLink() {
        return (this.moreClickEmitter.observers.length > 0);
    }
}
EllipsisDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ellipsis]',
                exportAs: 'ellipsis'
            },] }
];
EllipsisDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
EllipsisDirective.propDecorators = {
    ellipsisCharacters: [{ type: Input, args: ['ellipsis',] }],
    ellipsisContent: [{ type: Input, args: ['ellipsis-content',] }],
    ellipsisWordBoundaries: [{ type: Input, args: ['ellipsis-word-boundaries',] }],
    ellipsisSubstrFn: [{ type: Input, args: ['ellipsis-substr-fn',] }],
    resizeDetectionStrategy: [{ type: Input, args: ['ellipsis-resize-detection',] }],
    moreClickEmitter: [{ type: Output, args: ['ellipsis-click-more',] }],
    changeEmitter: [{ type: Output, args: ['ellipsis-change',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxsaXBzaXMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LWVsbGlwc2lzL3NyYy9saWIvZGlyZWN0aXZlcy9lbGxpcHNpcy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLE1BQU0sRUFJTixNQUFNLEVBQ04sV0FBVyxFQUVaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxjQUFjLElBQUksc0JBQXNCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNuRixPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUdwRCxJQUFJLGNBQWMsR0FBRyxzQkFBc0IsQ0FBQztBQUU1Qzs7O0dBR0c7QUFLSCxNQUFNLE9BQU8saUJBQWlCO0lBdUk1Qjs7T0FFRztJQUNILFlBQ1UsVUFBbUMsRUFDbkMsUUFBbUIsRUFDbkIsTUFBYyxFQUNPLFVBQWtCO1FBSHZDLGVBQVUsR0FBVixVQUFVLENBQXlCO1FBQ25DLGFBQVEsR0FBUixRQUFRLENBQVc7UUFDbkIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNPLGVBQVUsR0FBVixVQUFVLENBQVE7UUFwSGpEOztXQUVHO1FBQ0ssMkJBQXNCLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQWdCckQ7Ozs7V0FJRztRQUN3QixvQkFBZSxHQUFvQixJQUFJLENBQUM7UUE0Qm5FOzs7OztXQUtHO1FBQzRCLHFCQUFnQixHQUE2QixJQUFJLFlBQVksRUFBRSxDQUFDO1FBRy9GOzs7O1dBSUc7UUFDd0Isa0JBQWEsR0FBeUIsSUFBSSxZ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QUUsWUFBWTtnQkFDdEIsUUFBUSxFQUFFLFVBQVU7YUFDckI7OztZQTVCQyxVQUFVO1lBQ1YsU0FBUztZQUlULE1BQU07WUFzS3FDLE1BQU0sdUJBQTlDLE1BQU0sU0FBQyxXQUFXOzs7aUNBbkdwQixLQUFLLFNBQUMsVUFBVTs4QkFPaEIsS0FBSyxTQUFDLGtCQUFrQjtxQ0FReEIsS0FBSyxTQUFDLDBCQUEwQjsrQkFPaEMsS0FBSyxTQUFDLG9CQUFvQjtzQ0FVMUIsS0FBSyxTQUFDLDJCQUEyQjsrQkFTakMsTUFBTSxTQUFDLHFCQUFxQjs0QkFRNUIsTUFBTSxTQUFDLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgUmVuZGVyZXIyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIE5nWm9uZSxcbiAgT25DaGFuZ2VzLFxuICBBZnRlclZpZXdJbml0LFxuICBPbkRlc3Ryb3ksXG4gIEluamVjdCxcbiAgUExBVEZPUk1fSUQsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlciBhcyBSZXNpemVPYnNlcnZlclBvbnlmaWxsIH0gZnJvbSAnQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXInO1xuaW1wb3J0IHsgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuXG5sZXQgUmVzaXplT2JzZXJ2ZXIgPSBSZXNpemVPYnNlcnZlclBvbnlmaWxsO1xuXG4vKipcbiAqIERpcmVjdGl2ZSB0byB0cnVuY2F0ZSB0aGUgY29udGFpbmVkIHRleHQsIGlmIGl0IGV4Y2VlZHMgdGhlIGVsZW1lbnQncyBib3VuZGFyaWVzXG4gKiBhbmQgYXBwZW5kIGNoYXJhY3RlcnMgKGNvbmZpZ3VyYWJsZSwgZGVmYXVsdCAnLi4uJykgaWYgc28uXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tlbGxpcHNpc10nLFxuICBleHBvcnRBczogJ2VsbGlwc2lzJ1xufSlcbmV4cG9ydCBjbGFzcyBFbGxpcHNpc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95LCBBZnRlclZpZXdJbml0IHtcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCB0ZXh0IChub3QgdHJ1bmNhdGVkIHlldClcbiAgICovXG4gIHByaXZhdGUgb3JpZ2luYWxUZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZlcmVuY2VkIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgZWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBJbm5lciBkaXYgZWxlbWVudCAod2lsbCBiZSBhdXRvLWNyZWF0ZWQpXG4gICAqL1xuICBwcml2YXRlIGlubmVyRWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBBbmNob3IgdGFnIHdyYXBwaW5nIHRoZSBgZWxsaXBzaXNDaGFyYWN0ZXJzYFxuICAgKi9cbiAgcHJpdmF0ZSBtb3JlQW5jaG9yOiBIVE1MQW5jaG9yRWxlbWVudDtcblxuICBwcml2YXRlIHByZXZpb3VzRGltZW5zaW9uczoge1xuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXJcbiAgfTtcblxuICAvKipcbiAgICogU3ViamVjdCB0cmlnZ2VyZWQgd2hlbiByZXNpemUgbGlzdGVuZXJzIHNob3VsZCBiZSByZW1vdmVkXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZVJlc2l6ZUxpc3RlbmVycyQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBjbGljayBsaXN0ZW5lclxuICAgKiBvbiB0aGUgbGluayBgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnNgIGFyZSB3cmFwcGVkIGluLlxuICAgKi9cbiAgcHJpdmF0ZSBkZXN0cm95TW9yZUNsaWNrTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcyBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIHRoaXMgd2lsbCBiZSB1c2VkIGFzIGEgc3RyaW5nIHRvIGFwcGVuZCB0b1xuICAgKiB0aGUgdHJ1bmNhdGVkIGNvbnRlbnRzLlxuICAgKiBFbHNlICcuLi4nIHdpbGwgYmUgYXBwZW5kZWQuXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzJykgZWxsaXBzaXNDaGFyYWN0ZXJzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1jb250ZW50IGh0bWwgYXR0cmlidXRlXG4gICAqIElmIHBhc3NlZCB0aGlzIGlzIHVzZWQgYXMgY29udGVudCwgZWxzZSBjb250ZW50c1xuICAgKiBhcmUgZmV0Y2hlZCBmcm9tIHRleHRDb250ZW50XG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLWNvbnRlbnQnKSBlbGxpcHNpc0NvbnRlbnQ6IHN0cmluZyB8IG51bWJlciA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCBlYWNoIGNoYXJhY3RlciB3aWxsIGJlIGludGVycHJldGVkXG4gICAqIGFzIGEgd29yZCBib3VuZGFyeSBhdCB3aGljaCB0aGUgdGV4dCBtYXkgYmUgdHJ1bmNhdGVkLlxuICAgKiBFbHNlIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQgYXQgYW55IGNoYXJhY3Rlci5cbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtd29yZC1ib3VuZGFyaWVzJykgZWxsaXBzaXNXb3JkQm91bmRhcmllczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byB1c2UgZm9yIHN0cmluZyBzcGxpdHRpbmcuIERlZmF1bHRzIHRvIHRoZSBuYXRpdmUgYFN0cmluZyNzdWJzdHJgLlxuICAgKiAoVGhpcyBtYXkgZm9yIGV4YW1wbGUgYmUgdXNlZCB0byBhdm9pZCBzcGxpdHRpbmcgc3Vycm9nYXRlIHBhaXJzLSB1c2VkIGJ5IHNvbWUgZW1vamlzIC1cbiAgICogYnkgcHJvdmlkaW5nIGEgbGliIHN1Y2ggYXMgcnVuZXMuKVxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy1zdWJzdHItZm4nKSBlbGxpcHNpc1N1YnN0ckZuOiAgKHN0cjogc3RyaW5nLCBmcm9tOiBudW1iZXIsIGxlbmd0aD86IG51bWJlcikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtcmVzaXplLWRldGVjdGlvbiBodG1sIGF0dHJpYnV0ZVxuICAgKiBBbGdvcml0aG0gdG8gdXNlIHRvIGRldGVjdCBlbGVtZW50L3dpbmRvdyByZXNpemUgLSBhbnkgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogJ3Jlc2l6ZS1vYnNlcnZlcic6IChkZWZhdWx0KSBVc2UgbmF0aXZlIFJlc2l6ZU9ic2VydmVyIC0gc2VlXG4gICAqICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNpemVPYnNlcnZlclxuICAgKiAgICBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2p1Z2dsZS9yZXNpemUtb2JzZXJ2ZXJcbiAgICogJ3dpbmRvdyc6IE9ubHkgY2hlY2sgaWYgdGhlIHdob2xlIHdpbmRvdyBoYXMgYmVlbiByZXNpemVkL2NoYW5nZWQgb3JpZW50YXRpb24gYnkgdXNpbmcgYW5ndWxhcidzIGJ1aWx0LWluIEhvc3RMaXN0ZW5lclxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uJykgcmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3k6XG4gICAgJycgfCAnbWFudWFsJyB8ICdyZXNpemUtb2JzZXJ2ZXInIHwgJ3dpbmRvdyc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1jbGljay1tb3JlIGh0bWwgYXR0cmlidXRlXG4gICAqIElmIGFueXRoaW5nIGlzIHBhc3NlZCwgdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyB3aWxsIGJlXG4gICAqIHdyYXBwZWQgaW4gPGE+PC9hPiB0YWdzIGFuZCBhbiBldmVudCBoYW5kbGVyIGZvciB0aGVcbiAgICogcGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpbmtcbiAgICovXG4gIEBPdXRwdXQoJ2VsbGlwc2lzLWNsaWNrLW1vcmUnKSBtb3JlQ2xpY2tFbWl0dGVyOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLWNoYW5nZSBodG1sIGF0dHJpYnV0ZVxuICAgKiBUaGlzIGVtaXRzIGFmdGVyIHdoaWNoIGluZGV4IHRoZSB0ZXh0IGhhcyBiZWVuIHRydW5jYXRlZC5cbiAgICogSWYgaXQgaGFzbid0IGJlZW4gdHJ1bmNhdGVkLCBudWxsIGlzIGVtaXR0ZWQuXG4gICAqL1xuICBAT3V0cHV0KCdlbGxpcHNpcy1jaGFuZ2UnKSBjaGFuZ2VFbWl0dGVyOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgdG8gcXVpY2tseSBmaW5kIHRoZSBsYXJnZXN0IG51bWJlciBmb3JcbiAgICogd2hpY2ggYGNhbGxiYWNrKG51bWJlcilgIHN0aWxsIHJldHVybnMgdHJ1ZS5cbiAgICogQHBhcmFtICBtYXggICAgICBIaWdoZXN0IHBvc3NpYmxlIG51bWJlclxuICAgKiBAcGFyYW0gIGNhbGxiYWNrIFNob3VsZCByZXR1cm4gdHJ1ZSBhcyBsb25nIGFzIHRoZSBwYXNzZWQgbnVtYmVyIGlzIHZhbGlkXG4gICAqIEByZXR1cm4gICAgICAgICAgTGFyZ2VzdCBwb3NzaWJsZSBudW1iZXJcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIG51bWVyaWNCaW5hcnlTZWFyY2gobWF4OiBudW1iZXIsIGNhbGxiYWNrOiAobjogbnVtYmVyKSA9PiBib29sZWFuKTogbnVtYmVyIHtcbiAgICBsZXQgbG93ID0gMDtcbiAgICBsZXQgaGlnaCA9IG1heDtcbiAgICBsZXQgYmVzdCA9IC0xO1xuICAgIGxldCBtaWQ6IG51bWJlcjtcblxuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICAgIG1pZCA9IH5+KChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2sobWlkKTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmVzdCA9IG1pZDtcbiAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGVsbGlwc2lzIGlucHV0IHRvIHN0cmluZ1xuICAgKiBAcGFyYW0gaW5wdXQgc3RyaW5nIG9yIG51bWJlciB0byBiZSBkaXNwbGF5ZWQgYXMgYW4gZWxsaXBzaXNcbiAgICogQHJldHVybiAgICAgIGlucHV0IGNvbnZlcnRlZCB0byBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGNvbnZlcnRFbGxpcHNpc0lucHV0VG9TdHJpbmcoaW5wdXQ6IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nKGlucHV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGlyZWN0aXZlJ3MgY29uc3RydWN0b3JcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIG5nWm9uZTogTmdab25lLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0XG4gICkgeyB9XG5cbiAgLyoqXG4gICAqIEFuZ3VsYXIncyBpbml0IHZpZXcgbGlmZSBjeWNsZSBob29rLlxuICAgKiBJbml0aWFsaXplcyB0aGUgZWxlbWVudCBmb3IgZGlzcGxheWluZyB0aGUgZWxsaXBzaXMuXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKCFpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICAvLyBpbiBhbmd1bGFyIHVuaXZlcnNhbCB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGUgdWdseVxuICAgICAgLy8gRE9NIG1hbmlwdWxhdGlvbiBwcm9wZXJ0aWVzIHdlIHNhZGx5IG5lZWQgdG8gYWNjZXNzIGhlcmUsXG4gICAgICAvLyBzbyB3YWl0IHVudGlsIHdlJ3JlIGluIHRoZSBicm93c2VyOlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZWZlciBuYXRpdmUgUmVzaXplT2JzZXJ2ZXIgb3ZlciBwb255ZmlsbCwgaWYgYXZhaWxhYmxlOlxuICAgIGlmICgoPGFueT4gd2luZG93KS5SZXNpemVPYnNlcnZlciAhPSBudWxsKSB7XG4gICAgICBSZXNpemVPYnNlcnZlciA9ICg8YW55PiB3aW5kb3cpLlJlc2l6ZU9ic2VydmVyO1xuICAgIH1cblxuICAgIC8vIGxldCB0aGUgZWxsaXBzaXMgY2hhcmFjdGVycyBkZWZhdWx0IHRvICcuLi4nOlxuICAgIGlmICh0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9PT0gJycpIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzID0gJy4uLic7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG1vcmUgYW5jaG9yIGVsZW1lbnQ6XG4gICAgdGhpcy5tb3JlQW5jaG9yID0gPEhUTUxBbmNob3JFbGVtZW50PiB0aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB0aGlzLm1vcmVBbmNob3IuY2xhc3NOYW1lID0gJ25neC1lbGxpcHNpcy1tb3JlJztcbiAgICB0aGlzLm1vcmVBbmNob3IuaHJlZiA9ICcjJztcbiAgICB0aGlzLm1vcmVBbmNob3IudGV4dENvbnRlbnQgPSB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycztcblxuICAgIC8vIHBlcmZvcm0gcmVnZXggcmVwbGFjZSBvbiB3b3JkIGJvdW5kYXJpZXM6XG4gICAgaWYgKCF0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMpIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcyA9ICcnO1xuICAgIH1cbiAgICB0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMgPSAnWycgKyB0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMucmVwbGFjZSgvXFxcXG4vLCAnXFxuJykucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykgKyAnXSc7XG5cbiAgICBpZiAoIXRoaXMuZWxsaXBzaXNTdWJzdHJGbikge1xuICAgICAgdGhpcy5lbGxpcHNpc1N1YnN0ckZuID0gKHN0cjogc3RyaW5nLCBmcm9tOiBudW1iZXIsIGxlbmd0aD86IG51bWJlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihmcm9tLCBsZW5ndGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN0b3JlIHRoZSBvcmlnaW5hbCBjb250ZW50cyBvZiB0aGUgZWxlbWVudDpcbiAgICB0aGlzLmVsZW0gPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWxsaXBzaXNDb250ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmVsbGlwc2lzQ29udGVudCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSBFbGxpcHNpc0RpcmVjdGl2ZS5jb252ZXJ0RWxsaXBzaXNJbnB1dFRvU3RyaW5nKHRoaXMuZWxsaXBzaXNDb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLm9yaWdpbmFsVGV4dCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsZW0udGV4dENvbnRlbnQudHJpbSgpO1xuICAgIH1cblxuICAgIC8vIGFkZCBhIHdyYXBwZXIgZGl2IChyZXF1aXJlZCBmb3IgcmVzaXplIGV2ZW50cyB0byB3b3JrIHByb3Blcmx5KTpcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbSwgJ2lubmVySFRNTCcsICcnKTtcbiAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmlubmVyRWxlbSwgJ25neC1lbGxpcHNpcy1pbm5lcicpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZVRleHQodGhpcy5vcmlnaW5hbFRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0sIHRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtLCB0aGlzLmlubmVyRWxlbSk7XG5cbiAgICB0aGlzLnByZXZpb3VzRGltZW5zaW9ucyA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLmVsZW0uY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuZWxlbS5jbGllbnRIZWlnaHRcbiAgICB9O1xuXG4gICAgLy8gc3RhcnQgbGlzdGVuaW5nIGZvciByZXNpemUgZXZlbnRzOlxuICAgIHRoaXMuYWRkUmVzaXplTGlzdGVuZXIodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGNoYW5nZSBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIENoYW5nZSBvcmlnaW5hbCB0ZXh0IChpZiB0aGUgZWxsaXBzaXMtY29udGVudCBoYXMgYmVlbiBwYXNzZWQpXG4gICAqIGFuZCByZS1yZW5kZXJcbiAgICovXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBjb25zdCBtb3JlQW5jaG9yUmVxdWlyZXNDaGFuZ2UgPSB0aGlzLm1vcmVBbmNob3IgJiYgY2hhbmdlc1snZWxsaXBzaXNDaGFyYWN0ZXJzJ107XG4gICAgaWYgKG1vcmVBbmNob3JSZXF1aXJlc0NoYW5nZSkge1xuICAgICAgdGhpcy5tb3JlQW5jaG9yLnRleHRDb250ZW50ID0gdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxlbVxuICAgICAgICAmJiB0eXBlb2YgdGhpcy5lbGxpcHNpc0NvbnRlbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICYmIChcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsVGV4dCAhPT0gRWxsaXBzaXNEaXJlY3RpdmUuY29udmVydEVsbGlwc2lzSW5wdXRUb1N0cmluZyh0aGlzLmVsbGlwc2lzQ29udGVudClcbiAgICAgICAgICB8fCBtb3JlQW5jaG9yUmVxdWlyZXNDaGFuZ2VcbiAgICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSBFbGxpcHNpc0RpcmVjdGl2ZS5jb252ZXJ0RWxsaXBzaXNJbnB1dFRvU3RyaW5nKHRoaXMuZWxsaXBzaXNDb250ZW50KTtcbiAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgZGVzdHJveSBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIC8vIEluIGFuZ3VsYXIgdW5pdmVyc2FsIHdlIGRvbid0IGhhdmUgYW55IGxpc3RlbmVycyBob29rZWQgdXAgKGFsbCByZXF1aXJpbmcgdWdseSBET00gbWFuaXB1bGF0aW9uIG1ldGhvZHMpLFxuICAgIC8vIHNvIHdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlbSwgaWYgd2UncmUgaW5zaWRlIHRoZSBicm93c2VyOlxuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgYWxsIHJlc2l6ZSBsaXN0ZW5lcnNcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZVJlc2l6ZUxpc3RlbmVycyQubmV4dCgpO1xuICAgIHRoaXMucmVtb3ZlUmVzaXplTGlzdGVuZXJzJC5jb21wbGV0ZSgpO1xuICB9XG5cblxuICAvKipcbiAgICogU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGNhbGwgYXBwbHlFbGxpcHNpcygpIHdoZW5ldmVyIGEgcmVzaXplIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBsaXN0ZW5lciAod2luZG93L2VsZW1lbnQpIGRlcGVuZHMgb24gdGhlIHJlc2l6ZURldGVjdGlvblN0cmF0ZWd5LlxuICAgKiBAcGFyYW0gdHJpZ2dlck5vdz1mYWxzZSBpZiB0cnVlLCB0aGUgZWxsaXBzaXMgaXMgYXBwbGllZCBpbW1lZGlhdGVseVxuICAgKi9cbiAgcHJpdmF0ZSBhZGRSZXNpemVMaXN0ZW5lcih0cmlnZ2VyTm93ID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kgPSAnJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgJ21hbnVhbCc6XG4gICAgICAgIC8vIFVzZXJzIHdpbGwgdHJpZ2dlciBhcHBseUVsbGlwc2lzIHZpYSB0aGUgcHVibGljIEFQSVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dpbmRvdyc6XG4gICAgICAgIHRoaXMuYWRkV2luZG93UmVzaXplTGlzdGVuZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodHlwZW9mIChjb25zb2xlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgTm8gc3VjaCBlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uIHN0cmF0ZWd5OiAnJHt0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5fScuIFVzaW5nICdyZXNpemUtb2JzZXJ2ZXInIGluc3RlYWRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBjYXNlICdyZXNpemUtb2JzZXJ2ZXInOlxuICAgICAgY2FzZSAnJzpcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRyaWdnZXJOb3cgJiYgdGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gY2FsbCBhcHBseUVsbGlwc2lzKCkgd2hlbmV2ZXIgdGhlIHdpbmRvdyBnZXRzIHJlc2l6ZWQuXG4gICAqL1xuICBwcml2YXRlIGFkZFdpbmRvd1Jlc2l6ZUxpc3RlbmVyKCkge1xuICAgIGNvbnN0IHJlbW92ZVdpbmRvd1Jlc2l6ZUxpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ3dpbmRvdycsICdyZXNpemUnLCAoKSA9PiB7XG4gICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZW1vdmVSZXNpemVMaXN0ZW5lcnMkLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHJlbW92ZVdpbmRvd1Jlc2l6ZUxpc3RlbmVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBjYWxsIGFwcGx5RWxsaXBzaXMoKSB3aGVuZXZlciB0aGUgZWxlbWVudFxuICAgKiBoYXMgYmVlbiByZXNpemVkLlxuICAgKi9cbiAgcHJpdmF0ZSBhZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoKSB7XG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzRGltZW5zaW9ucy53aWR0aCAhPT0gdGhpcy5lbGVtLmNsaWVudFdpZHRoIHx8IHRoaXMucHJldmlvdXNEaW1lbnNpb25zLmhlaWdodCAhPT0gdGhpcy5lbGVtLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMucHJldmlvdXNEaW1lbnNpb25zLndpZHRoID0gdGhpcy5lbGVtLmNsaWVudFdpZHRoO1xuICAgICAgICAgIHRoaXMucHJldmlvdXNEaW1lbnNpb25zLmhlaWdodCA9IHRoaXMuZWxlbS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtKTtcbiAgICB0aGlzLnJlbW92ZVJlc2l6ZUxpc3RlbmVycyQucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKCkgPT4gcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbmFsIHRleHQncyB0cnVuY2F0ZWQgdmVyc2lvbi4gSWYgdGhlIHRleHQgcmVhbGx5IG5lZWRlZCB0b1xuICAgKiBiZSB0cnVuY2F0ZWQsIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzIHdpbGwgYmUgYXBwZW5kZWQuXG4gICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIHRoZSB0ZXh0IG1heSBoYXZlXG4gICAqIEByZXR1cm4gc3RyaW5nICAgICAgIHRoZSB0cnVuY2F0ZWQgc3RyaW5nXG4gICAqL1xuICBwcml2YXRlIGdldFRydW5jYXRlZFRleHQobWF4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5vcmlnaW5hbFRleHQgfHwgdGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoIDw9IG1heCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxUZXh0O1xuICAgIH1cblxuICAgIGNvbnN0IHRydW5jYXRlZFRleHQgPSB0aGlzLmVsbGlwc2lzU3Vic3RyRm4odGhpcy5vcmlnaW5hbFRleHQsIDAsIG1heCk7XG4gICAgaWYgKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcyA9PT0gJ1tdJyB8fCB0aGlzLm9yaWdpbmFsVGV4dC5jaGFyQXQobWF4KS5tYXRjaCh0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMpKSB7XG4gICAgICByZXR1cm4gdHJ1bmNhdGVkVGV4dDtcbiAgICB9XG5cbiAgICBsZXQgaSA9IG1heCAtIDE7XG4gICAgd2hpbGUgKGkgPiAwICYmICF0cnVuY2F0ZWRUZXh0LmNoYXJBdChpKS5tYXRjaCh0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMpKSB7XG4gICAgICBpLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVsbGlwc2lzU3Vic3RyRm4odHJ1bmNhdGVkVGV4dCwgMCwgaSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cnVuY2F0ZWQgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGlubmVyIGRpdlxuICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCB0aGUgdGV4dCBtYXkgaGF2ZVxuICAgKiBAcGFyYW0gYWRkTW9yZUxpc3RlbmVyPWZhbHNlIGxpc3RlbiBmb3IgY2xpY2sgb24gdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyBhbmNob3IgdGFnIGlmIHRoZSB0ZXh0IGhhcyBiZWVuIHRydW5jYXRlZFxuICAgKiBAcmV0dXJucyBsZW5ndGggb2YgcmVtYWluaW5nIHRleHQgKGV4Y2x1ZGluZyB0aGUgZWxsaXBzaXNDaGFyYWN0ZXJzLCBpZiB0aGV5IHdlcmUgYWRkZWQpXG4gICAqL1xuICBwcml2YXRlIHRydW5jYXRlVGV4dChtYXg6IG51bWJlciwgYWRkTW9yZUxpc3RlbmVyID0gZmFsc2UpOiBudW1iZXIge1xuICAgIGxldCB0ZXh0ID0gdGhpcy5nZXRUcnVuY2F0ZWRUZXh0KG1heCk7XG4gICAgY29uc3QgdHJ1bmNhdGVkTGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgY29uc3QgdGV4dFRydW5jYXRlZCA9ICh0cnVuY2F0ZWRMZW5ndGggIT09IHRoaXMub3JpZ2luYWxUZXh0Lmxlbmd0aCk7XG5cbiAgICBpZiAodGV4dFRydW5jYXRlZCAmJiAhdGhpcy5zaG93TW9yZUxpbmspIHtcbiAgICAgIHRleHQgKz0gdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnM7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmlubmVyRWxlbSwgJ3RleHRDb250ZW50JywgdGV4dCk7XG5cbiAgICBpZiAodGV4dFRydW5jYXRlZCAmJiB0aGlzLnNob3dNb3JlTGluaykge1xuICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLmlubmVyRWxlbSwgdGhpcy5tb3JlQW5jaG9yKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIG1vcmUgY2xpY2sgbGlzdGVuZXI6XG4gICAgaWYgKHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB0ZXh0IGhhcyBiZWVuIHRydW5jYXRlZCwgYWRkIGEgbW9yZSBjbGljayBsaXN0ZW5lcjpcbiAgICBpZiAoYWRkTW9yZUxpc3RlbmVyICYmIHRleHRUcnVuY2F0ZWQpIHtcbiAgICAgIHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5tb3JlQW5jaG9yLCAnY2xpY2snLCAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICBpZiAoIWUudGFyZ2V0IHx8ICEoPEhUTUxFbGVtZW50PiBlLnRhcmdldCkuY2xhc3NMaXN0LmNvbnRhaW5zKCduZ3gtZWxsaXBzaXMtbW9yZScpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5tb3JlQ2xpY2tFbWl0dGVyLmVtaXQoZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1bmNhdGVkTGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgZWxsaXBzaXMgaW4gdGhlIGlubmVyIGRpdiBpZiB0aGUgdGV4dCB3b3VsZCBleGNlZWQgdGhlIGJvdW5kYXJpZXNcbiAgICovXG4gIHB1YmxpYyBhcHBseUVsbGlwc2lzKCkge1xuICAgIC8vIFJlbW92ZSB0aGUgcmVzaXplIGxpc3RlbmVyIGFzIGNoYW5naW5nIHRoZSBjb250YWluZWQgdGV4dCB3b3VsZCB0cmlnZ2VyIGV2ZW50czpcbiAgICB0aGlzLnJlbW92ZVJlc2l6ZUxpc3RlbmVycyQubmV4dCgpO1xuXG4gICAgLy8gRmluZCB0aGUgYmVzdCBsZW5ndGggYnkgdHJpYWwgYW5kIGVycm9yOlxuICAgIGNvbnN0IG1heExlbmd0aCA9IEVsbGlwc2lzRGlyZWN0aXZlLm51bWVyaWNCaW5hcnlTZWFyY2godGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoLCBjdXJMZW5ndGggPT4ge1xuICAgICAgdGhpcy50cnVuY2F0ZVRleHQoY3VyTGVuZ3RoKTtcbiAgICAgIHJldHVybiAhdGhpcy5pc092ZXJmbG93aW5nO1xuICAgIH0pO1xuXG4gICAgLy8gQXBwbHkgdGhlIGJlc3QgbGVuZ3RoOlxuICAgIGNvbnN0IGZpbmFsTGVuZ3RoID0gdGhpcy50cnVuY2F0ZVRleHQobWF4TGVuZ3RoLCB0aGlzLnNob3dNb3JlTGluayk7XG5cbiAgICAvLyBSZS1hdHRhY2ggdGhlIHJlc2l6ZSBsaXN0ZW5lcjpcbiAgICB0aGlzLmFkZFJlc2l6ZUxpc3RlbmVyKCk7XG5cbiAgICAvLyBFbWl0IGNoYW5nZSBldmVudDpcbiAgICBpZiAodGhpcy5jaGFuZ2VFbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNoYW5nZUVtaXR0ZXIuZW1pdChcbiAgICAgICAgKHRoaXMub3JpZ2luYWxUZXh0Lmxlbmd0aCA9PT0gZmluYWxMZW5ndGgpID8gbnVsbCA6IGZpbmFsTGVuZ3RoXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHRleHQgaXMgZXhjZWVkaW5nIHRoZSBlbGVtZW50J3MgYm91bmRhcmllcyBvciBub3RcbiAgICovXG4gIHByaXZhdGUgZ2V0IGlzT3ZlcmZsb3dpbmcoKTogYm9vbGVhbiB7XG4gICAgLy8gRW5mb3JjZSBoaWRkZW4gb3ZlcmZsb3cgKHJlcXVpcmVkIHRvIGNvbXBhcmUgY2xpZW50IHdpZHRoL2hlaWdodCB3aXRoIHNjcm9sbCB3aWR0aC9oZWlnaHQpXG4gICAgY29uc3QgY3VycmVudE92ZXJmbG93ID0gdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93O1xuICAgIGlmICghY3VycmVudE92ZXJmbG93IHx8IGN1cnJlbnRPdmVyZmxvdyA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICBjb25zdCBpc092ZXJmbG93aW5nID0gdGhpcy5lbGVtLmNsaWVudFdpZHRoIDwgdGhpcy5lbGVtLnNjcm9sbFdpZHRoIC0gMSB8fCB0aGlzLmVsZW0uY2xpZW50SGVpZ2h0IDwgdGhpcy5lbGVtLnNjcm9sbEhlaWdodCAtIDE7XG5cbiAgICAvLyBSZXNldCBvdmVyZmxvdyB0byB0aGUgb3JpZ2luYWwgY29uZmlndXJhdGlvbjpcbiAgICB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3cgPSBjdXJyZW50T3ZlcmZsb3c7XG5cbiAgICByZXR1cm4gaXNPdmVyZmxvd2luZztcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBgZWxsaXBzaXNDaGFyYWN0ZXJzYCBhcmUgdG8gYmUgd3JhcHBlZCBpbnNpZGUgYW4gYW5jaG9yIHRhZyAoaWYgdGhleSBhcmUgc2hvd24gYXQgYWxsKVxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgc2hvd01vcmVMaW5rKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5tb3JlQ2xpY2tFbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwKTtcbiAgfVxufVxuIl19